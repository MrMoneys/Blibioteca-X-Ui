<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Luau Exploit — Luau PRO (Exploit Edition)</title>

    <!-- CodeMirror 5 -> CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/lua/lua.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/anyword-hint.min.js"></script>

    <style>
        :root{--bg:#282a36;--panel:#1e1f29;--accent:#6272a4;--muted:#44475a;--fg:#f8f8f2;--success:#50fa7b;--warning:#ffb86c;--error:#ff5555}
        html, body {height:100%;margin:0;padding:0;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;background:var(--bg);color:var(--fg)}
        .toolbar{padding:10px;background:var(--panel);display:flex;align-items:center;gap:12px;flex-wrap:wrap}
        .toolbar label{color:var(--fg);font-weight:600}
        #snippet-selector{background:var(--muted);color:var(--fg);border:1px solid var(--accent);border-radius:6px;padding:6px;font-family:inherit}
        .CodeMirror{border-top:1px solid var(--accent);height:calc(100vh - 102px);font-size:15px}
        .CodeMirror-hints{background:var(--bg) !important;color:var(--fg) !important;border:1px solid var(--accent) !important}
        li.CodeMirror-hint-active{background:var(--muted) !important;color:#fff !important}
        .editor-container{flex-grow:1}
        .kbd{background:#111318;border-radius:4px;padding:6px 8px;font-size:13px;color:var(--fg);border:1px solid rgba(255,255,255,0.03)}
        .small{font-size:13px;color:#cfd6ff}
        textarea{width:100%;height:100%}
        .btn{background:var(--accent);color:var(--fg);border:none;border-radius:6px;padding:6px 12px;cursor:pointer;font-family:inherit;font-weight:600;transition:all 0.2s}
        .btn:hover{opacity:0.9}
        .btn-clear{background:var(--error)}
        .btn-save{background:var(--success)}
        .btn-copy{background:var(--warning)}
        .btn-group{display:flex;gap:6px;margin-left:auto}
        .status{font-size:12px;color:var(--accent);padding:0 10px}
        @media (max-width:700px){.CodeMirror{font-size:17px;height:calc(100vh - 140px)}.btn-group{margin-left:0;width:100%;justify-content:flex-end}}
    </style>
</head>
<body>
    <div class="toolbar">
        <label>⚡ Snippets:</label>
        <select id="snippet-selector" onchange="insertSnippet()">
            <option value="">-- Inserir snippet rápido --</option>
            <optgroup label="Visual">
                <option value="esp">ESP Básico (Highlight)</option>
                <option value="espAdvanced">ESP Avançado (Boxes + Names)</option>
                <option value="chams">Chams (Material)</option>
            </optgroup>
            <optgroup label="Combat">
                <option value="aimbot">Aimbot Base (Visão)</option>
                <option value="silentAim">Silent Aim</option>
                <option value="triggerBot">Trigger Bot</option>
            </optgroup>
            <optgroup label="Movement">
                <option value="teleport">Teleport PivotTo</option>
                <option value="speed">Speed Hack</option>
                <option value="fly">Fly Script</option>
                <option value="noclip">Noclip</option>
            </optgroup>
            <optgroup label="Protection">
                <option value="antiKick">Anti-Kick (hookfunc)</option>
                <option value="antiAfk">Anti-AFK</option>
                <option value="antiBan">Anti-Ban (Básico)</option>
            </optgroup>
            <optgroup label="Utility">
                <option value="remoteSpy">Remote Spy (Hook Remotes)</option>
                <option value="autoFarm">Auto Farm (Básico)</option>
                <option value="itemGrabber">Item Grabber</option>
            </optgroup>
            <optgroup label="Core">
                <option value="loadstring">Loadstring / getgenv</option>
                <option value="hook">Hook Functions</option>
                <option value="tween">TweenService</option>
                <option value="console">Console Logger</option>
            </optgroup>
        </select>

        <div class="kbd">Atalhos: <span class="small">Ctrl+Espaço = Autocomplete</span> • <span class="small">Ctrl+1..9 = Snippets</span></div>
        
        <div class="btn-group">
            <button class="btn btn-clear" onclick="clearEditor()">Limpar</button>
            <button class="btn btn-save" onclick="saveScript()">Salvar</button>
            <button class="btn btn-copy" onclick="copyToClipboard()">Copiar</button>
        </div>
        
        <div class="status" id="status-message"></div>
    </div>

    <div class="editor-container">
        <textarea id="luauEditor" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false">-- Editor Luau PRO — Exploit Edition
-- Comece a digitar e pressione Ctrl+Espaço para forçar o autocomplete

-- Exemplos rápidos:
-- getgenv().MyFlag = true
-- loadstring(game:HttpGet("https://..."))()

local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(p)
    print("Jogador entrou: "..p.Name)
end)</textarea>
    </div>

    <script>
        // =====================
        // LISTAS DE SUGESTÃO
        // =====================
        const luauKeywords = [
            "and","break","do","else","elseif","end","false","for","function",
            "if","in","local","nil","not","or","repeat","return","then",
            "true","until","while","continue"
        ];

        const robloxGlobals = [
            "game","workspace","script","plugin","wait","print","warn","error",
            "Instance","Vector3","Vector2","CFrame","Color3","BrickColor","Enum",
            "math","table","string","os","debug","coroutine","typeof","tick"
        ];

        const robloxServices = [
            "Players","TweenService","ReplicatedStorage","ServerScriptService","ServerStorage",
            "StarterPlayer","StarterGui","StarterPack","UserInputService","ContextActionService",
            "Debris","Lighting","SoundService","MarketplaceService","TeleportService","DataStoreService"
        ];

        const robloxInstanceTypes = [
            "Part","MeshPart","Model","Folder","ScreenGui","TextLabel","TextButton","Frame",
            "RemoteEvent","RemoteFunction","BindableEvent","BindableFunction","Tool","Humanoid","Head"
        ];

        const robloxProperties = [
            "Name","Parent","ClassName","Archivable","Position","Size","CFrame","Orientation",
            "Velocity","Anchored","CanCollide","Transparency","BrickColor","Color","Material",
            "Reflectance","Locked","Value","Enabled","Text","TextColor3","TextSize","Visible"
        ];

        const robloxMethods = [
            "FindFirstChild","WaitForChild","FindFirstChildOfClass","GetChildren","GetDescendants",
            "IsA","Clone","Destroy","ClearAllChildren","FireServer()","InvokeServer()","Connect","Disconnect","Wait","Play","Stop","Create"
        ];

        const robloxEvents = [
            "Touched","TouchEnded","ChildAdded","ChildRemoved","AncestryChanged","Changed",
            "PlayerAdded","PlayerRemoving","OnServerEvent","OnClientEvent","MouseButton1Click","InputBegan","InputEnded"
        ];

        // Funções / helpers usadas em exploits (comuns em executors)
        const exploitFunctions = [
            "getgenv","shared","setreadonly","hookfunction","hookmetamethod","checkcaller",
            "getfenv","setfenv","getrawmetatable","setrawmetatable","getupvalue","setupvalue",
            "getconnections","firetouchinterest","fireproximityprompt","sethiddenproperty","getsenv",
            "writefile","readfile","isfile","delfile","isfolder","makefolder","HttpGet","HttpPost",
            "loadstring","syn.request","http_request","request","LocalPlayer","LowerTorso","UpperTorso",
            "CanCollide"
        ];
        
        
        const exploitFunctionsext = [
            "math.noise", "math.clamp", "math.sign", "math.round", 
"math.lerp", "math.randomseed", "math.floor", "math.ceil", 
"math.abs", "math.acos", "math.asin", "math.atan", 
"math.atan2", "math.cos", "math.cosh", "math.deg", 
"math.exp", "math.fmod", "math.frexp", "math.huge", 
"math.ldexp", "math.log", "math.log10", "math.max", 
"math.min", "math.modf", "math.pi", "math.pow", 
"math.rad", "math.random", "math.sin", "math.sinh", 
"math.sqrt", "math.tan", "math.tanh","NetworkOwner", "NetworkIsOwner", "AssemblyLinearVelocity", 
"AssemblyAngularVelocity", "Massless", "CollisionFidelity", 
"RootPriority", "Elasticity", "Friction", "ReceiveAge", 
"PhysicsSendRate", "NetworkIsSleeping", "NetworkPingInterval", 
"NetworkOwnershipRule", "NetworkReplicator", "RobloxLocked",
"Enum.HumanoidStateType", "Enum.Material", 
"Enum.FormFactor", "Enum.PartType", "Enum.EasingStyle", 
"Enum.EasingDirection", "Enum.UserInputType", 
"Enum.KeyCode", "Enum.Font", "Enum.TextXAlignment", 
"Enum.TextYAlignment", "Enum.VerticalAlignment", 
"Enum.HorizontalAlignment", "Enum.NormalId"
        ];

        // Mescla tudo para fallback
        const allSuggestions = [...new Set([
            ...luauKeywords, ...robloxGlobals, ...robloxServices, ...robloxInstanceTypes,
            ...robloxProperties, ...robloxMethods, ...robloxEvents, ...exploitFunctions, ...exploitFunctionsext
        ])].sort();

        // =====================
        // INICIALIZAÇÃO DO EDITOR
        // =====================
        const editor = CodeMirror.fromTextArea(document.getElementById("luauEditor"), {
            lineNumbers: true,
            mode: "lua",
            theme: "dracula",
            matchBrackets: true,
            autoCloseBrackets: true,
            indentUnit: 4,
            extraKeys: {
                "Ctrl-Space": function(cm){ cm.showHint({hint: CodeMirror.hint.luau, completeSingle: false}); },
                "Ctrl-1": function(cm){ insertSnippetByKey('esp'); },
                "Ctrl-2": function(cm){ insertSnippetByKey('aimbot'); },
                "Ctrl-3": function(cm){ insertSnippetByKey('antiKick'); },
                "Ctrl-4": function(cm){ insertSnippetByKey('teleport'); },
                "Ctrl-5": function(cm){ insertSnippetByKey('remoteSpy'); },
                "Ctrl-6": function(cm){ insertSnippetByKey('loadstring'); },
                "Ctrl-7": function(cm){ insertSnippetByKey('hook'); },
                "Ctrl-8": function(cm){ insertSnippetByKey('tween'); },
                "Ctrl-9": function(cm){ insertSnippetByKey('noclip'); },
                "Ctrl-S": function(cm){ saveScript(); return false; } // Previne o save padrão do navegador
            }
        });

        // =====================
        // HINT CUSTOMIZADO (LUAU + CONTEXTO EXPLOIT)
        // =====================
        CodeMirror.registerHelper('hint', 'luau', function(cm, options){
            const cur = cm.getCursor();
            const token = cm.getTokenAt(cur);
            const start = token.start;
            const end = cur.ch;
            const curWord = token.string.slice(0, end - start);

            // Lista base: combinar suggestions filter por prefix
            const baseList = allSuggestions.filter(w => w.toLowerCase().startsWith(curWord.toLowerCase()));

            // Contextual rules
            // Se o usuário está digitando game:GetService("... -> sugestões de serviços
            const lineBefore = cm.getLine(cur.line).slice(0, cur.ch);
            const serviceMatch = lineBefore.match(/game\s*:\s*GetService\s*\(\s*[\"\']([^\"\']*)$/);
            if (serviceMatch) {
                return {list: robloxServices.filter(s => s.toLowerCase().startsWith(serviceMatch[1].toLowerCase())), from: CodeMirror.Pos(cur.line, token.start), to: CodeMirror.Pos(cur.line, token.end)};
            }

            // Se está escrevendo Instance.new("... -> sugerir tipos de instância
            const instMatch = lineBefore.match(/Instance.new\(\s*[\"\']([^\"\']*)$/);
            if (instMatch) {
                return {list: robloxInstanceTypes.filter(s => s.toLowerCase().startsWith(instMatch[1].toLowerCase())), from: CodeMirror.Pos(cur.line, token.start), to: CodeMirror.Pos(cur.line, token.end)};
            }

            // Se começa com "fire" sugerir funções de firetouch/fireproximity
            if (/^fire/i.test(curWord)) {
                const fireList = exploitFunctions.filter(f => /^fire/i.test(f));
                return {list: fireList.length ? fireList : baseList, from: CodeMirror.Pos(cur.line, token.start), to: CodeMirror.Pos(cur.line, token.end)};
            }

            // Se começa com getgenv / loadstring -> sugerir explit funcs
            if (/^getgenv|^loadstring|^hook/i.test(curWord)) {
                const ex = exploitFunctions.filter(f => f.toLowerCase().startsWith(curWord.toLowerCase()));
                return {list: ex.length ? ex : baseList, from: CodeMirror.Pos(cur.line, token.start), to: CodeMirror.Pos(cur.line, token.end)};
            }

            // Fallback: sugestões base + palavras do documento
            const anyword = CodeMirror.hint.anyword(cm) || {list: []};
            const combined = [...new Set([...baseList, ...anyword.list])].sort();
            return {list: combined, from: CodeMirror.Pos(cur.line, token.start), to: CodeMirror.Pos(cur.line, token.end)};
        });

        // Mostrar hint automaticamente ao digitar (apenas para tokens com >=2 chars)
        editor.on('keyup', function(cm, event){
            if (cm.state.completionActive) return;
            if (!event || !event.key) return;
            const key = event.key;
            if (key.length === 1 && /[a-zA-Z_]/.test(key)){
                const cur = cm.getCursor();
                const token = cm.getTokenAt(cur);
                if (token.string && token.string.length >= 2) {
                    cm.showHint({hint: CodeMirror.hint.luau, completeSingle:false});
                }
            }
        });

        // =====================
        // SNIPPETS ESPECIALIZADOS (Exploit-focused)
        // =====================
        const snippets = {
            esp: `\n-- Snippet: ESP Básico usando Highlight\nlocal Players = game:GetService("Players")\nlocal RunService = game:GetService("RunService")\n\nfor _, p in pairs(Players:GetPlayers()) do\n    if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then\n        local hrp = p.Character.HumanoidRootPart\n        local highlight = Instance.new("Highlight")\n        highlight.Adornee = p.Character\n        highlight.Parent = workspace\n    end\nend\n\n-- Atualizar dinamicamente pode ser necessário dependendo do jogo\n`,

            espAdvanced: `\n-- Snippet: ESP Avançado (Box + Nomes)\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\nlocal RunService = game:GetService("RunService")\n\nlocal function createEsp(player)\n    if player == LocalPlayer then return end\n    \n    local character = player.Character or player.CharacterAdded:Wait()\n    \n    -- Criar BillboardGui para o nome\n    local billboard = Instance.new("BillboardGui")\n    billboard.Name = "ESP_"..player.Name\n    billboard.Adornee = character:WaitForChild("Head")\n    billboard.Size = UDim2.new(0, 100, 0, 40)\n    billboard.StudsOffset = Vector3.new(0, 3, 0)\n    billboard.AlwaysOnTop = true\n    \n    local nameLabel = Instance.new("TextLabel", billboard)\n    nameLabel.Text = player.Name\n    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)\n    nameLabel.Position = UDim2.new(0, 0, 0, 0)\n    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)\n    nameLabel.BackgroundTransparency = 1\n    \n    -- Criar caixa ao redor do personagem\n    local box = Instance.new("BoxHandleAdornment")\n    box.Name = "ESPBox"\n    box.Adornee = character\n    box.AlwaysOnTop = true\n    box.ZIndex = 10\n    box.Size = character:GetExtentsSize() * 1.1\n    box.Transparency = 0.7\n    box.Color3 = Color3.fromRGB(255, 0, 0)\n    \n    billboard.Parent = character:WaitForChild("Head")\n    box.Parent = character\n    \n    -- Atualizar dinamicamente\n    local conn\n    conn = RunService.Heartbeat:Connect(function()\n        if not character or not character:FindFirstChild("HumanoidRootPart") then\n            conn:Disconnect()\n            return\n        end\n        box.CFrame = character:GetPivot()\n    end)\nend\n\n-- Aplicar a todos os jogadores\nfor _, player in pairs(Players:GetPlayers()) do\n    createEsp(player)\nend\n\nPlayers.PlayerAdded:Connect(createEsp)\n`,

            chams: `\n-- Snippet: Chams (Material transparente)\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\n\nlocal function applyChams(character)\n    for _, part in pairs(character:GetDescendants()) do\n        if part:IsA("BasePart") then\n            part.Material = Enum.Material.ForceField\n            part.Transparency = 0.5\n            part.Color = Color3.fromRGB(255, 0, 255)\n        end\n    end\nend\n\n-- Aplicar a todos os jogadores\nfor _, player in pairs(Players:GetPlayers()) do\n    if player ~= LocalPlayer and player.Character then\n        applyChams(player.Character)\n    end\n    player.CharacterAdded:Connect(applyChams)\nend\n\nPlayers.PlayerAdded:Connect(function(player)\n    player.CharacterAdded:Connect(applyChams)\nend)\n`,

            aimbot: `\n-- Snippet: Aimbot base (exemplo simplificado — ajuste para seu executor)\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\nlocal mouse = LocalPlayer:GetMouse()\nlocal enabled = true\nlocal targetKey = Enum.UserInputType.MouseButton2 -- Botão direito do mouse\n\nlocal function getClosestEnemy()\n    local closest, dist = nil, math.huge\n    for _, p in pairs(Players:GetPlayers()) do\n        if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then\n            local pos = workspace.CurrentCamera:WorldToViewportPoint(p.Character.HumanoidRootPart.Position)\n            local d = (Vector2.new(pos.X,pos.Y) - Vector2.new(mouse.X, mouse.Y)).magnitude\n            if d < dist then dist = d; closest = p end\n        end\n    end\n    return closest\nend\n\nlocal function aimAt(target)\n    if not target or not target.Character then return end\n    local hrp = target.Character:FindFirstChild("HumanoidRootPart")\n    if not hrp then return end\n    \n    workspace.CurrentCamera.CFrame = CFrame.lookAt(\n        workspace.CurrentCamera.CFrame.Position,\n        hrp.Position + Vector3.new(0, 1.5, 0) -- Ajuste para mirar no torso\n    )\nend\n\n-- Ativar com botão\ngame:GetService("UserInputService").InputBegan:Connect(function(input)\n    if input.UserInputType == targetKey then\n        local target = getClosestEnemy()\n        if target then\n            aimAt(target)\n        end\n    end\nend)\n`,

            silentAim: `\n-- Snippet: Silent Aim (exemplo básico)\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\nlocal RunService = game:GetService("RunService")\n\n-- Configurações\nlocal silentAimEnabled = true\nlocal fov = 60 -- Graus do campo de visão\nlocal hitChance = 100 -- Porcentagem de acerto\n\n-- Obter alvo mais próximo dentro do FOV\nlocal function getSilentTarget()\n    if not silentAimEnabled or math.random(1, 100) > hitChance then return nil end\n    \n    local closest, closestAngle = nil, math.rad(fov)\n    local camera = workspace.CurrentCamera\n    local cameraPos = camera.CFrame.Position\n    local cameraLook = camera.CFrame.LookVector\n    \n    for _, player in pairs(Players:GetPlayers()) do\n        if player ~= LocalPlayer and player.Character then\n            local hrp = player.Character:FindFirstChild("HumanoidRootPart")\n            if hrp then\n                local direction = (hrp.Position - cameraPos).Unit\n                local angle = math.acos(cameraLook:Dot(direction))\n                \n                if angle < closestAngle then\n                    closestAngle = angle\n                    closest = hrp\n                end\n            end\n        end\n    end\n    \n    return closest\nend\n\n-- Hook para mudar a direção do tiro (exemplo conceitual)\nif hookmetamethod then\n    local oldNamecall\n    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)\n        local method = getnamecallmethod()\n        if silentAimEnabled and method:lower() == "findpartonray" then\n            local target = getSilentTarget()\n            if target then\n                local args = {...}\n                local origin = args[1].Origin\n                local newRay = Ray.new(origin, (target.Position - origin).Unit * 1000)\n                return oldNamecall(self, newRay, unpack(args, 2))\n            end\n        end\n        return oldNamecall(self, ...)\n    end)\nend\n`,

            triggerBot: `\n-- Snippet: Trigger Bot (dispara automaticamente quando mira em um jogador)\nlocal Players = game:GetService("Players")\nlocal UserInputService = game:GetService("UserInputService")\nlocal LocalPlayer = Players.LocalPlayer\nlocal Mouse = LocalPlayer:GetMouse()\n\nlocal enabled = true\nlocal delay = 0.1 -- Atraso entre disparos\nlocal lastShot = 0\n\nlocal function isPlayerVisible(target)\n    if not target or not target.Character then return false end\n    \n    local humanoidRootPart = target.Character:FindFirstChild("HumanoidRootPart")\n    local humanoid = target.Character:FindFirstChild("Humanoid")\n    \n    if not humanoidRootPart or not humanoid or humanoid.Health <= 0 then return false end\n    \n    local camera = workspace.CurrentCamera\n    local origin = camera.CFrame.Position\n    local direction = (humanoidRootPart.Position - origin).Unit\n    \n    -- Verificar se há obstáculos\n    local raycastParams = RaycastParams.new()\n    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, target.Character}\n    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist\n    \n    local raycastResult = workspace:Raycast(origin, direction * 1000, raycastParams)\n    \n    if raycastResult and raycastResult.Instance:IsDescendantOf(target.Character) then\n        return true\n    end\n    \n    return false\nend\n\nlocal function findTarget()\n    for _, player in pairs(Players:GetPlayers()) do\n        if player ~= LocalPlayer and player.Character then\n            local humanoid = player.Character:FindFirstChild("Humanoid")\n            if humanoid and humanoid.Health > 0 then\n                local head = player.Character:FindFirstChild("Head")\n                if head then\n                    local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(head.Position)\n                    if onScreen then\n                        local mousePos = Vector2.new(Mouse.X, Mouse.Y)\n                        local headPos = Vector2.new(screenPos.X, screenPos.Y)\n                        \n                        if (headPos - mousePos).Magnitude < 30 then -- Raio de detecção\n                            if isPlayerVisible(player) then\n                                return player\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n    return nil\nend\n\n-- Simular clique do mouse\nlocal function simulateClick()\n    if tick() - lastShot < delay then return end\n    lastShot = tick()\n    \n    -- Depende do executor/exploit para simular input\n    if mousemoverel and mouse1click then\n        mouse1click()\n    end\nend\n\n-- Loop principal\nif RunService then\n    RunService.Heartbeat:Connect(function()\n        if not enabled then return end\n        \n        local target = findTarget()\n        if target then\n            simulateClick()\n        end\n    end)\nend\n`,

            antiKick: `\n-- Snippet: Anti-Kick usando hookfunction (exemplo comum em executors)\nif hookfunction then\n    local oldKick\n    \n    -- Hook para Player:Kick()\n    if typeof(Players.LocalPlayer.Kick) == "function" then\n        oldKick = hookfunction(Players.LocalPlayer.Kick, function(self, ...)\n            warn("[Anti-Kick] Bloqueado kick attempt:", ...)\n            return nil\n        end)\n    end\n    \n    -- Hook para game:GetService("Players").LocalPlayer.Kick\n    local localPlayerMeta = getrawmetatable(Players.LocalPlayer)\n    if localPlayerMeta and localPlayerMeta.__namecall then\n        local oldNamecall = hookmetamethod(localPlayerMeta, "__namecall", function(self, ...)\n            local method = getnamecallmethod()\n            if method == "Kick" then\n                warn("[Anti-Kick] Bloqueado namecall kick attempt")\n                return nil\n            end\n            return oldNamecall(self, ...)\n        end)\n    end\n    \n    -- Hook para remotes que podem causar kick\n    local function hookRemoteKicks()\n        for _, remote in pairs(game:GetDescendants()) do\n            if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then\n                if not remote.Hooked then\n                    remote.Hooked = true\n                    \n                    if remote:IsA("RemoteEvent") then\n                        local oldFire = hookfunction(remote.FireServer, function(self, ...)\n                            local args = {...}\n                            if tostring(args[1]):lower():find("kick") then\n                                warn("[Anti-Kick] Bloqueado remote kick attempt:", remote:GetFullName())\n                                return nil\n                            end\n                            return oldFire(self, ...)\n                        end)\n                    else\n                        local oldInvoke = hookfunction(remote.InvokeServer, function(self, ...)\n                            local args = {...}\n                            if tostring(args[1]):lower():find("kick") then\n                                warn("[Anti-Kick] Bloqueado remote invoke kick attempt:", remote:GetFullName())\n                                return nil\n                            end\n                            return oldInvoke(self, ...)\n                        end)\n                    end\n                end\n            end\n        end\n    end\n    \n    hookRemoteKicks()\n    game.DescendantAdded:Connect(function(desc)\n        if desc:IsA("RemoteEvent") or desc:IsA("RemoteFunction") then\n            wait(1) -- Esperar um pouco para evitar detecção\n            hookRemoteKicks()\n        end\n    end)\nend\n`,

            antiAfk: `\n-- Snippet: Anti-AFK (prevente ser kickado por inatividade)\nlocal VirtualInputManager = game:GetService("VirtualInputManager")\nlocal UserInputService = game:GetService("UserInputService")\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\n\nlocal antiAfkEnabled = true\nlocal lastMovement = tick()\n\n-- Movimentação falsa para evitar AFK\nlocal function fakeMovement()\n    if not antiAfkEnabled then return end\n    \n    -- Simular pequeno movimento do mouse\n    if VirtualInputManager then\n        VirtualInputManager:SendMouseMoveEvent(10, 10, game)\n        wait(0.1)\n        VirtualInputManager:SendMouseMoveEvent(-10, -10, game)\n    end\n    \n    -- Alternativamente, simular tecla pressionada\n    if UserInputService then\n        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)\n        wait(0.1)\n        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)\n    end\nend\n\n-- Verificar se o jogador está realmente inativo\nlocal function isActuallyAfk()\n    local lastInput = UserInputService:GetLastInputType()\n    local timeSinceLastInput = tick() - UserInputService:GetLastInputTime()\n    \n    return timeSinceLastInput > 60 -- 1 minuto sem input\nend\n\n-- Loop principal\nif RunService then\n    RunService.Heartbeat:Connect(function()\n        if not antiAfkEnabled then return end\n        \n        -- Verificar a cada 30 segundos\n        if tick() - lastMovement > 30 then\n            if isActuallyAfk() then\n                fakeMovement()\n            end\n            lastMovement = tick()\n        end\n    end)\nend\n`,

            antiBan: `\n-- Snippet: Anti-Ban (Básico - hook de funções de banimento)\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\n\nif hookfunction then\n    -- Hook para funções comuns de banimento\n    local function hookBanFunctions()\n        -- Hook para game:GetService("Players").LocalPlayer.Kick (já coberto no anti-kick)\n        \n        -- Procurar por RemoteEvents/RemoteFunctions suspeitos\n        for _, remote in pairs(game:GetDescendants()) do\n            if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then\n                if not remote.Hooked then\n                    remote.Hooked = true\n                    \n                    local remoteName = remote.Name:lower()\n                    if remoteName:find("ban") or remoteName:find("punish") or remoteName:find("report") then\n                        if remote:IsA("RemoteEvent") then\n                            local oldFire = hookfunction(remote.FireServer, function(self, ...)\n                                warn("[Anti-Ban] Bloqueado remote ban attempt:", remote:GetFullName())\n                                return nil\n                            end)\n                        else\n                            local oldInvoke = hookfunction(remote.InvokeServer, function(self, ...)\n                                warn("[Anti-Ban] Bloqueado remote invoke ban attempt:", remote:GetFullName())\n                                return nil\n                            end)\n                        end\n                    end\n                end\n            end\n        end\n    end\n    \n    hookBanFunctions()\n    game.DescendantAdded:Connect(function(desc)\n        if desc:IsA("RemoteEvent") or desc:IsA("RemoteFunction") then\n            wait(1) -- Esperar um pouco para evitar detecção\n            hookBanFunctions()\n        end\n    end)\n    \n    -- Hook para funções de banimento no servidor (se acessíveis)\n    if getgenv then\n        getgenv().requestBan = function() warn("[Anti-Ban] Bloqueado requestBan") return nil end\n        getgenv().banPlayer = function() warn("[Anti-Ban] Bloqueado banPlayer") return nil end\n    end\nend\n`,

            teleport: `\n-- Snippet: Teleport seguro usando PivotTo\nlocal player = game.Players.LocalPlayer\nlocal char = player.Character or player.CharacterAdded:Wait()\nlocal root = char:WaitForChild("HumanoidRootPart")\n\nlocal function teleportTo(pos)\n    if not root or not root:IsDescendantOf(workspace) then return end\n    \n    -- Verificar se a posição é válida\n    if typeof(pos) == "Vector3" then\n        -- Usar PivotTo se disponível (mais seguro)\n        if root.PivotTo then\n            root:PivotTo(CFrame.new(pos))\n        else\n            -- Fallback para CFrame (pode causar detecção)\n            root.CFrame = CFrame.new(pos)\n        end\n    end\nend\n\n-- Exemplo de uso:\n-- teleportTo(Vector3.new(0, 50, 0))\n-- teleportTo(workspace:FindFirstChild("TargetPart").Position)\n`,

            speed: `\n-- Snippet: Speed Hack (modifica a velocidade do Humanoid)\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\nlocal UserInputService = game:GetService("UserInputService")\n\nlocal speedHackEnabled = true\nlocal speedMultiplier = 2 -- 2x velocidade normal\nlocal defaultWalkSpeed = 16\n\nlocal function updateSpeed(character)\n    if not speedHackEnabled then return end\n    \n    local humanoid = character:FindFirstChildOfClass("Humanoid")\n    if humanoid then\n        humanoid.WalkSpeed = defaultWalkSpeed * speedMultiplier\n    end\nend\n\n-- Aplicar quando o personagem spawnar\nLocalPlayer.CharacterAdded:Connect(updateSpeed)\nif LocalPlayer.Character then\n    updateSpeed(LocalPlayer.Character)\nend\n\n-- Toggle com tecla (exemplo: LeftShift)\nUserInputService.InputBegan:Connect(function(input, gameProcessed)\n    if gameProcessed then return end\n    \n    if input.KeyCode == Enum.KeyCode.LeftShift then\n        speedMultiplier = 3 -- Aumentar velocidade quando Shift é pressionado\n        if LocalPlayer.Character then\n            updateSpeed(LocalPlayer.Character)\n        end\n    end\nend)\n\nUserInputService.InputEnded:Connect(function(input, gameProcessed)\n    if gameProcessed then return end\n    \n    if input.KeyCode == Enum.KeyCode.LeftShift then\n        speedMultiplier = 2 -- Voltar ao normal quando Shift é solto\n        if LocalPlayer.Character then\n            updateSpeed(LocalPlayer.Character)\n        end\n    end\nend)\n`,

            fly: `\n-- Snippet: Fly Script (voar pelo mapa)\nlocal Players = game:GetService("Players")\nlocal UserInputService = game:GetService("UserInputService")\nlocal RunService = game:GetService("RunService")\nlocal LocalPlayer = Players.LocalPlayer\n\nlocal flyEnabled = false\nlocal flySpeed = 50\nlocal flyKeys = {\n    [Enum.KeyCode.W] = false,\n    [Enum.KeyCode.A] = false,\n    [Enum.KeyCode.S] = false,\n    [Enum.KeyCode.D] = false,\n    [Enum.KeyCode.Space] = false,\n    [Enum.KeyCode.LeftShift] = false\n}\n\nlocal function toggleFly()\n    flyEnabled = not flyEnabled\n    \n    if flyEnabled then\n        -- Iniciar voo\n        local character = LocalPlayer.Character\n        if not character then return end\n        \n        local humanoid = character:FindFirstChildOfClass("Humanoid")\n        if humanoid then\n            humanoid.PlatformStand = true\n        end\n        \n        -- Conexão para movimento\n        local flyConnection\n        flyConnection = RunService.Heartbeat:Connect(function(dt)\n            if not flyEnabled or not LocalPlayer.Character then\n                flyConnection:Disconnect()\n                return\n            end\n            \n            local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")\n            if not rootPart then return end\n            \n            local camera = workspace.CurrentCamera\n            local cf = camera.CFrame\n            \n            local direction = Vector3.new(\n                (flyKeys[Enum.KeyCode.D] and 1 or 0) + (flyKeys[Enum.KeyCode.A] and -1 or 0),\n                (flyKeys[Enum.KeyCode.Space] and 1 or 0) + (flyKeys[Enum.KeyCode.LeftShift] and -1 or 0,\n                (flyKeys[Enum.KeyCode.S] and 1 or 0) + (flyKeys[Enum.KeyCode.W] and -1 or 0\n            )\n            \n            if direction.Magnitude > 0 then\n                direction = cf:VectorToWorldSpace(direction).Unit\n                rootPart.Velocity = direction * flySpeed\n            else\n                rootPart.Velocity = Vector3.new(0, 0, 0)\n            end\n        end)\n    else\n        -- Parar voo\n        local character = LocalPlayer.Character\n        if character then\n            local humanoid = character:FindFirstChildOfClass("Humanoid")\n            if humanoid then\n                humanoid.PlatformStand = false\n            end\n            \n            local rootPart = character:FindFirstChild("HumanoidRootPart")\n            if rootPart then\n                rootPart.Velocity = Vector3.new(0, 0, 0)\n            end\n        end\n    end\nend\n\n-- Configurar controles\nUserInputService.InputBegan:Connect(function(input, gameProcessed)\n    if gameProcessed then return end\n    \n    if input.KeyCode == Enum.KeyCode.F then -- Toggle com F\n        toggleFly()\n    elseif flyKeys[input.KeyCode] ~= nil then\n        flyKeys[input.KeyCode] = true\n    end\nend)\n\nUserInputService.InputEnded:Connect(function(input, gameProcessed)\n    if gameProcessed then return end\n    \n    if flyKeys[input.KeyCode] ~= nil then\n        flyKeys[input.KeyCode] = false\n    end\nend)\n`,

            noclip: `\n-- Snippet: Noclip (atravessar paredes)\nlocal Players = game:GetService("Players")\nlocal RunService = game:GetService("RunService")\nlocal LocalPlayer = Players.LocalPlayer\n\nlocal noclipEnabled = true\nlocal noclipConnection\n\nlocal function noclip(character)\n    if noclipConnection then noclipConnection:Disconnect() end\n    \n    noclipConnection = RunService.Stepped:Connect(function()\n        if not noclipEnabled or not character then\n            noclipConnection:Disconnect()\n            return\n        end\n        \n        for _, part in pairs(character:GetDescendants()) do\n            if part:IsA("BasePart") and part.CanCollide then\n                part.CanCollide = false\n            end\n        end\n    end)\nend\n\n-- Ativar quando o personagem spawnar\nLocalPlayer.CharacterAdded:Connect(noclip)\nif LocalPlayer.Character then\n    noclip(LocalPlayer.Character)\nend\n\n-- Toggle com tecla (exemplo: N)\ngame:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)\n    if gameProcessed then return end\n    \n    if input.KeyCode == Enum.KeyCode.N then\n        noclipEnabled = not noclipEnabled\n        if LocalPlayer.Character then\n            noclip(LocalPlayer.Character)\n        end\n    end\nend)\n`,

            remoteSpy: `\n-- Snippet: Remote Spy (hook Remotes)\nlocal ReplicatedStorage = game:GetService("ReplicatedStorage")\nlocal HttpService = game:GetService("HttpService")\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\n\nlocal remoteSpyEnabled = true\nlocal logToFile = false\nlocal logFilePath = "remote_logs.txt"\n\nlocal function logRemote(remote, args, isInvoke)\n    if not remoteSpyEnabled then return end\n    \n    local remoteType = isInvoke and "RemoteFunction" or "RemoteEvent"\n    local action = isInvoke and "InvokeServer" or "FireServer"\n    \n    local logMessage = string.format(\n        "[%s] %s.%s(%s)\\n\\n",\n        os.date("%X"),\n        remote:GetFullName(),\n        action,\n        HttpService:JSONEncode(args)\n    )\n    \n    -- Imprimir no console\n    print(logMessage)\n    \n    -- Log para arquivo se habilitado\n    if logToFile and writefile then\n        if not isfile(logFilePath) then\n            writefile(logFilePath, "Remote Logs:\\n=============\\n")\n        end\n        appendfile(logFilePath, logMessage)\n    end\nend\n\nlocal function hookRemote(remote)\n    if not remoteSpyEnabled then return end\n    \n    if remote:IsA("RemoteEvent") then\n        if not remote.Hooked then\n            remote.Hooked = true\n            \n            local oldFire = hookfunction(remote.FireServer, function(self, ...)\n                logRemote(self, {...}, false)\n                return oldFire(self, ...)\n            end)\n        end\n    elseif remote:IsA("RemoteFunction") then\n        if not remote.Hooked then\n            remote.Hooked = true\n            \n            local oldInvoke = hookfunction(remote.InvokeServer, function(self, ...)\n                logRemote(self, {...}, true)\n                return oldInvoke(self, ...)\n            end)\n        end\n    end\nend\n\n-- Hook em todos os remotes existentes\nfor _, remote in pairs(ReplicatedStorage:GetDescendants()) do\n    if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then\n        hookRemote(remote)\n    end\nend\n\n-- Hook em novos remotes\ngame.DescendantAdded:Connect(function(desc)\n    if remoteSpyEnabled and (desc:IsA("RemoteEvent") or desc:IsA("RemoteFunction")) then\n        wait(1) -- Esperar um pouco para evitar detecção\n        hookRemote(desc)\n    end\nend)\n`,

            autoFarm: `\n-- Snippet: Auto Farm (Básico - coleta itens automaticamente)\nlocal Players = game:GetService("Players")\nlocal Workspace = game:GetService("Workspace")\nlocal RunService = game:GetService("RunService")\nlocal LocalPlayer = Players.LocalPlayer\n\nlocal autoFarmEnabled = true\nlocal collectDistance = 20\nlocal collectDelay = 1\nlocal lastCollect = 0\n\nlocal function findNearestItem()\n    local character = LocalPlayer.Character\n    if not character then return nil end\n    \n    local rootPart = character:FindFirstChild("HumanoidRootPart")\n    if not rootPart then return nil end\n    \n    local closestItem, closestDist = nil, math.huge\n    \n    -- Procurar por itens para coletar (ajuste para o seu jogo)\n    for _, item in pairs(Workspace:GetDescendants()) do\n        if item.Name == "Item" or item.Name == "Coin" or item.Name == "Collectable" then\n            if item:IsA("BasePart") then\n                local dist = (item.Position - rootPart.Position).Magnitude\n                if dist < collectDistance and dist < closestDist then\n                    closestDist = dist\n                    closestItem = item\n                end\n            end\n        end\n    end\n    \n    return closestItem\nend\n\nlocal function collectItem(item)\n    if not item or not item:IsDescendantOf(Workspace) then return end\n    \n    -- Depende do jogo - exemplos de métodos para coletar:\n    -- 1. FireServer em um RemoteEvent\n    -- 2. FireTouchInterest\n    -- 3. Chamar uma função no cliente\n    \n    -- Exemplo com FireTouchInterest (comum em muitos jogos)\n    if firetouchinterest then\n        local character = LocalPlayer.Character\n        if character then\n            local rootPart = character:FindFirstChild("HumanoidRootPart")\n            if rootPart then\n                firetouchinterest(rootPart, item, 0) -- Touch begin\n                firetouchinterest(rootPart, item, 1) -- Touch end\n            end\n        end\n    end\n    \n    -- Exemplo com RemoteEvent (ajuste o nome para o seu jogo)\n    local collectRemote = Workspace:FindFirstChild("CollectRemote") or ReplicatedStorage:FindFirstChild("CollectRemote")\n    if collectRemote and collectRemote:IsA("RemoteEvent") then\n        collectRemote:FireServer(item)\n    end\nend\n\n-- Loop principal\nif RunService then\n    RunService.Heartbeat:Connect(function()\n        if not autoFarmEnabled then return end\n        \n        if tick() - lastCollect > collectDelay then\n            local item = findNearestItem()\n            if item then\n                collectItem(item)\n            end\n            lastCollect = tick()\n        end\n    end)\nend\n`,

            itemGrabber: `\n-- Snippet: Item Grabber (pega itens próximos automaticamente)\nlocal Players = game:GetService("Players")\nlocal Workspace = game:GetService("Workspace")\nlocal RunService = game:GetService("RunService")\nlocal LocalPlayer = Players.LocalPlayer\n\nlocal grabberEnabled = true\nlocal grabDistance = 50\nlocal grabDelay = 0.5\nlocal lastGrab = 0\n\nlocal function grabNearbyItems()\n    if not grabberEnabled then return end\n    \n    local character = LocalPlayer.Character\n    if not character then return end\n    \n    local rootPart = character:FindFirstChild("HumanoidRootPart")\n    if not rootPart then return end\n    \n    -- Procurar por itens próximos\n    for _, item in pairs(Workspace:GetDescendants()) do\n        if item:IsA("BasePart") and (item.Name:find("Item") or item.Name:find("Coin") or item.Name:find("Collect")) then\n            local dist = (item.Position - rootPart.Position).Magnitude\n            if dist <= grabDistance then\n                -- Teleportar o item para o jogador\n                if item:FindFirstChildOfClass("BodyVelocity") then\n                    item:FindFirstChildOfClass("BodyVelocity"):Destroy()\n                end\n                \n                item.CFrame = rootPart.CFrame + Vector3.new(0, 0, -2)\n                \n                -- Alternativa: usar FireTouchInterest\n                if firetouchinterest then\n                    firetouchinterest(rootPart, item, 0)\n                    firetouchinterest(rootPart, item, 1)\n                end\n            end\n        end\n    end\nend\n\n-- Loop principal\nif RunService then\n    RunService.Heartbeat:Connect(function()\n        if not grabberEnabled then return end\n        \n        if tick() - lastGrab > grabDelay then\n            grabNearbyItems()\n            lastGrab = tick()\n        end\n    end)\nend\n`,

            loadstring: `\n-- Snippet: loadstring / getgenv usage\nif getgenv then\n    -- Configurações globais\n    getgenv().MySettings = {\n        Aimbot = true,\n        ESP = false,\n        Speed = 1.5,\n        Keybinds = {\n            ToggleMenu = Enum.KeyCode.RightShift,\n            ToggleESP = Enum.KeyCode.F1\n        }\n    }\nend\n\n-- Carregar script remoto\nlocal function loadScript(url)\n    local content\n    \n    -- Tentar diferentes métodos de request dependendo do executor\n    if syn and syn.request then\n        local response = syn.request({Url = url, Method = "GET"})\n        content = response.Body\n    elseif http_request then\n        content = http_request({Url = url, Method = "GET"}).Body\n    else\n        content = game:HttpGet(url, true)\n    end\n    \n    if loadstring then\n        local success, err = pcall(function()\n            loadstring(content)()\n        end)\n        \n        if not success then\n            warn("Falha ao carregar script:", err)\n        end\n    else\n        warn("loadstring não disponível neste executor")\n    end\nend\n\n-- Exemplo de uso:\n-- loadScript("https://example.com/script.lua")\n`,

            hook: `\n-- Snippet: hookfunction / hookmetamethod exemplo\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\n\nif hookfunction then\n    -- Exemplo 1: Hook em uma função global\n    local oldPrint = hookfunction(print, function(...)\n        local args = {...}\n        table.insert(args, 1, "[Hooked]")\n        return oldPrint(unpack(args))\n    end)\n    \n    -- Exemplo 2: Hook em uma função de instância\n    if LocalPlayer.Kick then\n        local oldKick = hookfunction(LocalPlayer.Kick, function(self, ...)\n            warn("[Hook] Tentativa de kick bloqueada:", ...)\n            return nil\n        end)\n    end\nend\n\nif hookmetamethod then\n    -- Exemplo 3: Hook em __namecall\n    local oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)\n        local method = getnamecallmethod()\n        \n        -- Bloquear chamadas suspeitas\n        if tostring(method):lower():find("kick") or tostring(method):lower():find("ban") then\n            warn("[Hook] Bloqueado namecall suspeito:", method)\n            return nil\n        end\n        \n        return oldNamecall(self, ...)\n    end)\n    \n    -- Exemplo 4: Hook em __index\n    local oldIndex = hookmetamethod(game, "__index", function(self, key)\n        -- Monitorar acessos a propriedades\n        if key == "PrivateData" or key == "SecureData" then\n            warn("[Hook] Acesso a propriedade sensível:", key)\n            return nil\n        end\n        \n        return oldIndex(self, key)\n    end)\nend\n`,

            tween: `\n-- Snippet: TweenService (Vários perfis)\nlocal TweenService = game:GetService("TweenService")\nlocal Players = game:GetService("Players")\nlocal LocalPlayer = Players.LocalPlayer\n\n-- Exemplo 1: Tween básico\nlocal part = workspace:FindFirstChild("TargetPart") or Instance.new("Part", workspace)\npart.Size = Vector3.new(2, 2, 2)\npart.Anchored = true\npart.Position = Vector3.new(0, 10, 0)\n\nlocal tweenInfo = TweenInfo.new(\n    2, -- Tempo\n    Enum.EasingStyle.Quad, -- Estilo\n    Enum.EasingDirection.InOut, -- Direção\n    0, -- Repetições\n    false, -- Reversa\n    0 -- Delay\n)\n\nlocal tween = TweenService:Create(part, tweenInfo, {\n    Position = Vector3.new(0, 50, 0),\n    Color = Color3.fromRGB(255, 0, 0),\n    Transparency = 0.5\n})\n\ntween:Play()\n\n-- Exemplo 2: Tween com callback\nlocal function tweenCharacter(cframe)\n    local character = LocalPlayer.Character\n    if not character then return end\n    \n    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")\n    if not humanoidRootPart then return end\n    \n    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear)\n    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {\n        CFrame = cframe\n    })\n    \n    tween.Completed:Connect(function()\n        print("Tween completado!")\n    end)\n    \n    tween:Play()\nend\n\n-- Exemplo 3: Tween em loop\nlocal rotatingPart = Instance.new("Part", workspace)\nrotatingPart.Size = Vector3.new(4, 1, 4)\nrotatingPart.Anchored = true\nrotatingPart.Position = Vector3.new(0, 20, 0)\n\nlocal function rotatePart()\n    local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Linear)\n    local tween = TweenService:Create(rotatingPart, tweenInfo, {\n        CFrame = rotatingPart.CFrame * CFrame.Angles(0, math.rad(90), 0)\n    })\n    \n    tween.Completed:Connect(rotatePart)\n    tween:Play()\nend\n\nrotatePart()\n`,

            console: `\n-- Snippet: Console Logger (melhorar output do console)\nlocal Console = {\n    enabled = true,\n    timestamps = true,\n    logLevel = 2, -- 1=Error, 2=Warn, 3=Info, 4=Debug\n    colors = {\n        error = Color3.fromRGB(255, 85, 85),\n        warn = Color3.fromRGB(255, 187, 85),\n        info = Color3.fromRGB(85, 255, 255),\n        debug = Color3.fromRGB(170, 170, 170),\n        timestamp = Color3.fromRGB(187, 187, 187)\n    }\n}\n\nfunction Console:log(level, message, ...)\n    if not self.enabled or level > self.logLevel then return end\n    \n    local levelName, levelColor\n    if level == 1 then\n        levelName, levelColor = "ERROR", self.colors.error\n    elseif level == 2 then\n        levelName, levelColor = "WARN", self.colors.warn\n    elseif level == 3 then\n        levelName, levelColor = "INFO", self.colors.info\n    else\n        levelName, levelColor = "DEBUG", self.colors.debug\n    end\n    \n    -- Formatar mensagem\n    local formattedMsg = string.format(message, ...)\n    \n    -- Adicionar timestamp se habilitado\n    local prefix = ""\n    if self.timestamps then\n        prefix = string.format("[%s] ", os.date("%X"))\n    end\n    \n    -- Imprimir com cor se possível\n    if rconsoleprint then\n        if self.timestamps then\n            rconsoleprint(self.colors.timestamp, prefix)\n        end\n        rconsoleprint(levelColor, string.format("[%s] ", levelName))\n        rconsoleprint("\\n")\n    else\n        print(string.format("%s[%s] %s", prefix, levelName, formattedMsg))\n    end\nend\n\n-- Métodos de conveniência\nfunction Console:error(...) self:log(1, ...) end\nfunction Console:warn(...) self:log(2, ...) end\nfunction Console:info(...) self:log(3, ...) end\nfunction Console:debug(...) self:log(4, ...) end\n\n-- Exemplo de uso:\n-- Console:warn("Aviso: %s está com valor baixo", "Health")\n-- Console:error("Falha ao conectar: %d", 404)\n-- Console:info("Player %s entrou no jogo", player.Name)\n-- Console:debug("Posição atual: %.2f, %.2f, %.2f", pos.X, pos.Y, pos.Z)\n`
        };

        function insertSnippet(){
            const selector = document.getElementById('snippet-selector');
            const type = selector.value;
            if (!type) return;
            editor.replaceSelection(snippets[type] || '');
            selector.selectedIndex = 0;
            editor.focus();
            showStatus('Snippet inserido: ' + type, 'success');
        }

        function insertSnippetByKey(key){
            // mapear chaves para snippets
            const map = {
                esp: 'esp', aimbot: 'aimbot', antiKick: 'antiKick', 
                teleport: 'teleport', remoteSpy: 'remoteSpy', 
                loadstring: 'loadstring', hook: 'hook', tween: 'tween',
                noclip: 'noclip'
            };
            const name = map[key] || key;
            if (snippets[name]){
                editor.replaceSelection(snippets[name]);
                editor.focus();
                showStatus('Snippet inserido: ' + name, 'success');
            }
        }

        // =====================
        // FUNÇÕES DE CONTROLE DO EDITOR
        // =====================
        function clearEditor(){
            if(confirm('Tem certeza que deseja limpar o editor? Todo o conteúdo será perdido.')){
                editor.setValue('-- Editor limpo\n-- Comece a digitar ou insira um snippet\n');
                editor.focus();
                showStatus('Editor limpo', 'warning');
            }
        }

        function saveScript(){
            const content = editor.getValue();
            const blob = new Blob([content], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'script_luau_' + new Date().toISOString().slice(0,10) + '.lua';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus('Script salvo como ' + a.download, 'success');
        }

        function copyToClipboard(){
            const text = editor.getValue();
            navigator.clipboard.writeText(text).then(()=>{
                showStatus('Conteúdo copiado para a área de transferência', 'success');
            }, (e)=>{
                showStatus('Falha ao copiar: ' + e, 'error');
            });
        }

        function showStatus(message, type = 'info'){
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.style.color = `var(--${type})`;
            
            // Reset após 3 segundos
            setTimeout(() => {
                statusEl.textContent = '';
                statusEl.style.color = 'var(--accent)';
            }, 3000);
        }

        // =====================
        // AUTOSAVE E RECUPERAÇÃO
        // =====================
        const STORAGE_KEY = 'luau_exploit_editor_content_v1';
        // carregar
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) editor.setValue(saved);
        // autosave a cada 2s (debounced)
        let saveTimer = null;
        editor.on('change', function(){
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(()=>{
                localStorage.setItem(STORAGE_KEY, editor.getValue());
            }, 1500);
        });

        // =====================
        // Mensagem de pronto no console (debug)
        // =====================
        console.log('Luau Exploit Editor carregado — autocomplete e snippets prontos.');
    </script>
</body>
</html>
